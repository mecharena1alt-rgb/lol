--// FINAL MERGED GUI + FULL FUNCTIONALITY SCRIPT
--// LocalScript

--------------------------------------------------
-- SERVICES
--------------------------------------------------
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

local LP = Players.LocalPlayer

--------------------------------------------------
-- SINGLE SOURCE OF TRUTH (GUI + LOGIC)
--------------------------------------------------
local ENABLED = {
	["AimbotBTN"] = false,
	["X-rayBTN"] = true,
	["No clipBTN"] = false,
	["TP to playerBTN"] = false,
	["INF jumpBTN"] = true,
	["Jump heightBTN"] = true,
	["SpeedBTN"] = true,
	["Fly speedBTN"] = false,
}

local STATS = {
	TEXTBOX1 = 80, -- JumpHeight
	TEXTBOX2 = 80, -- WalkSpeed
	TEXTBOX3 = 80, -- FlySpeed
}

--------------------------------------------------
-- INTERNAL STATE (RESTORED)
--------------------------------------------------
local enemyList = {}
local currentIndex = 1
local tickTimer = 0

local highlights = {}
local bodyVelocity, bodyGyro
local savedCollision = {}

local defaultMovement = {
	WalkSpeed = nil,
	JumpHeight = nil,
	UseJumpPower = nil,
	JumpPower = nil
}

--------------------------------------------------
-- UTILS
--------------------------------------------------
local function isAlive(p)
	local h = p.Character and p.Character:FindFirstChildOfClass("Humanoid")
	return h and h.Health > 0
end

local function isEnemy(p)
	return p ~= LP and p.Team ~= LP.Team
end

--------------------------------------------------
-- ENEMY UPDATE
--------------------------------------------------
local function updateEnemies()
	table.clear(enemyList)

	for _, p in ipairs(Players:GetPlayers()) do
		if isEnemy(p) and isAlive(p) and p.Character and p.Character:FindFirstChild("Head") then
			table.insert(enemyList, p)
		end
	end

	table.sort(enemyList, function(a, b)
		return
			(Camera.CFrame.Position - a.Character.Head.Position).Magnitude <
			(Camera.CFrame.Position - b.Character.Head.Position).Magnitude
	end)

	if currentIndex > #enemyList then
		currentIndex = 1
	end
end

--------------------------------------------------
-- XRAY (FULL RESTORE)
--------------------------------------------------
local function applyXray()
	if not ENABLED["X-rayBTN"] then
		for _, h in pairs(highlights) do
			h:Destroy()
		end
		table.clear(highlights)
		return
	end

	for _, p in ipairs(enemyList) do
		if not highlights[p] then
			local h = Instance.new("Highlight")
			h.Adornee = p.Character
			h.FillTransparency = 0.5
			h.OutlineTransparency = 0
			h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
			h.FillColor = Color3.fromRGB(255, 0, 0)
			h.Parent = Camera
			highlights[p] = h
		end
	end
end

--------------------------------------------------
-- TRUE NOCLIP (FULL RESTORE)
--------------------------------------------------
local function saveCollisionState(char)
	savedCollision = {}
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			savedCollision[part] = {
				part.CanCollide,
				part.CanTouch,
				part.CanQuery
			}
		end
	end
end

local function restoreCollisionState()
	for part, s in pairs(savedCollision) do
		if part then
			part.CanCollide, part.CanTouch, part.CanQuery = s[1], s[2], s[3]
		end
	end
end

local function applyNoclip()
	if not ENABLED["No clipBTN"] then return end
	local char = LP.Character
	if not char then return end

	if not next(savedCollision) then
		saveCollisionState(char)
	end

	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = false
			part.CanTouch = false
			part.CanQuery = false
		end
	end
end

--------------------------------------------------
-- FLY (FULL RESTORE)
--------------------------------------------------
local function enableFly(on)
	local char = LP.Character
	if not char then return end

	local hrp = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hrp or not hum then return end

	if not on then
		if bodyVelocity then bodyVelocity:Destroy() end
		if bodyGyro then bodyGyro:Destroy() end
		bodyVelocity, bodyGyro = nil, nil
		hum.PlatformStand = false
		return
	end

	bodyVelocity = Instance.new("BodyVelocity", hrp)
	bodyVelocity.MaxForce = Vector3.new(1e9, 1e9, 1e9)

	bodyGyro = Instance.new("BodyGyro", hrp)
	bodyGyro.MaxTorque = Vector3.new(1e9, 1e9, 1e9)

	hum.PlatformStand = true
end

local function updateFly()
	if not ENABLED["Fly speedBTN"] or not bodyVelocity then return end
	local hum = LP.Character:FindFirstChildOfClass("Humanoid")
	local cam = Camera.CFrame
	local move = hum.MoveDirection

	local dir =
		(cam.LookVector * move:Dot(cam.LookVector)) +
		(cam.RightVector * move:Dot(cam.RightVector))

	if dir.Magnitude > 0 then dir = dir.Unit end

	bodyVelocity.Velocity = dir * STATS.TEXTBOX3
	bodyGyro.CFrame = cam
end

--------------------------------------------------
-- MOVEMENT HACKS (FULL RESTORE)
--------------------------------------------------
local function cacheDefaultMovement(hum)
	if not defaultMovement.WalkSpeed then
		defaultMovement.WalkSpeed = hum.WalkSpeed
		defaultMovement.JumpHeight = hum.JumpHeight
		defaultMovement.UseJumpPower = hum.UseJumpPower
		defaultMovement.JumpPower = hum.JumpPower
	end
end

local function applyMovement()
	local hum = LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	cacheDefaultMovement(hum)

	if ENABLED["SpeedBTN"] then
		hum.WalkSpeed = STATS.TEXTBOX2
	else
		hum.WalkSpeed = defaultMovement.WalkSpeed
	end

	if ENABLED["Jump heightBTN"] then
		hum.UseJumpPower = false
		hum.JumpHeight = STATS.TEXTBOX1
	else
		hum.UseJumpPower = defaultMovement.UseJumpPower
		hum.JumpHeight = defaultMovement.JumpHeight
		hum.JumpPower = defaultMovement.JumpPower
	end
end

--------------------------------------------------
-- INFINITE JUMP
--------------------------------------------------
UserInputService.JumpRequest:Connect(function()
	if ENABLED["INF jumpBTN"] then
		local hum = LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")
		if hum then
			hum:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end
end)

--------------------------------------------------
-- RANDOM TELEPORT
--------------------------------------------------
local function randomTeleport()
	if not ENABLED["TP to playerBTN"] then return end

	local char = LP.Character
	local myRoot = char and char:FindFirstChild("HumanoidRootPart")
	if not myRoot then return end

	local others = {}

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LP and plr.Character then
			local root = plr.Character:FindFirstChild("HumanoidRootPart")
			if root then table.insert(others, root) end
		end
	end

	if #others > 0 then
		myRoot.CFrame = others[math.random(#others)].CFrame + Vector3.new(0,3,0)
	end
end

--------------------------------------------------
-- RESPAWN FIX
--------------------------------------------------
LP.CharacterAdded:Connect(function()
	savedCollision = {}
	defaultMovement = {
		WalkSpeed = nil,
		JumpHeight = nil,
		UseJumpPower = nil,
		JumpPower = nil
	}
end)

--------------------------------------------------
-- MAIN LOOP (FULLY RESTORED)
--------------------------------------------------
RunService.RenderStepped:Connect(function(dt)
	tickTimer += dt

	if tickTimer >= 0.1 then
		tickTimer = 0
		updateEnemies()
		applyXray()
		applyMovement()
		randomTeleport()
	end

	applyNoclip()

	if ENABLED["Fly speedBTN"] then
		if not bodyVelocity then enableFly(true) end
		updateFly()
	else
		if bodyVelocity then enableFly(false) end
	end

	if ENABLED["AimbotBTN"] then
		local target = enemyList[currentIndex]
		if target then
			Camera.CFrame = CFrame.new(Camera.CFrame.Position, target.Character.Head.Position)
		end
	end
end)
